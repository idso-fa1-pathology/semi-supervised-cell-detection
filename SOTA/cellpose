{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "746524ed-97a7-47c4-bf2f-b05df846ec7b",
   "metadata": {},
   "source": [
    "# Import Cellpose"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c76b5dc8-a501-410f-b306-e327bdd2e42f",
   "metadata": {},
   "outputs": [],
   "source": [
    "from cellpose import models, io\n",
    "import numpy as np\n",
    "import os"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "be0a097f-1565-41ef-8aa6-70dfb33386e9",
   "metadata": {},
   "source": [
    "# Define the path to your images"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "24822def-9ed8-4c5b-8825-2021b01e6b98",
   "metadata": {},
   "outputs": [],
   "source": [
    "image_folder = '/rsrch5/home/plm/yshokrollahi/project4/val_pack/images'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a97f18e1-0a8a-4f79-bdc0-19470a618363",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load images\n",
    "files = io.get_image_files(image_folder, '')\n",
    "imgs = [io.imread(f) for f in files]\n",
    "\n",
    "# Since we're interested in the blue channel, we'll extract it.\n",
    "# Assuming RGB images, the blue channel is the third channel (index 2).\n",
    "blue_imgs = [img[:,:,2] for img in imgs]  # Extracting the blue channel\n",
    "\n",
    "# Initialize the Cellpose model\n",
    "model = models.Cellpose(gpu=False, model_type='cyto3')\n",
    "\n",
    "# Specify the cell diameter if known, otherwise set it to None\n",
    "cell_diameter = None\n",
    "\n",
    "# Run the model on the list of blue channel images\n",
    "# Note: For single-channel images like the blue channel, set channels=[0,0]\n",
    "masks, flows, styles, diams = model.eval(blue_imgs, diameter=cell_diameter, channels=[0,0])\n",
    "\n",
    "# Save the results\n",
    "# Save the results\n",
    "import numpy as np\n",
    "\n",
    "# Iterate over each file and its corresponding mask and flow\n",
    "import numpy as np\n",
    "\n",
    "# Iterate over each file and its corresponding mask and flow\n",
    "for i, f in enumerate(files):\n",
    "    base = os.path.splitext(f)[0]\n",
    "    \n",
    "    # Construct file name for masks\n",
    "    masks_file_name = f'{base}_masks.npy'\n",
    "    # Save masks to numpy file\n",
    "    np.save(masks_file_name, masks[i])\n",
    "    \n",
    "    # Construct file name for flows and save using npz for multiple components\n",
    "    flows_file_name = f'{base}_flows.npz'\n",
    "    # Assuming flows[i] is a list or tuple with multiple components\n",
    "    # Example: flows[i] might contain (flows, styles, dP, cellprob), depending on Cellpose version\n",
    "    # You would adjust the keys as appropriate for your data structure\n",
    "    np.savez(flows_file_name, flow=flows[i][0], styles=flows[i][1], dP=flows[i][2], cellprob=flows[i][3])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "62f05008-8908-4a5e-b49e-e4c3c192a5dc",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "# Function to load ground truth masks if they are stored as numpy arrays\n",
    "# Adjust the path pattern as needed\n",
    "def load_ground_truth_mask(file_path):\n",
    "    gt_path = file_path.replace('images', 'ground_truth').replace('.png', '_gt.npy')\n",
    "    try:\n",
    "        return np.load(gt_path)\n",
    "    except FileNotFoundError:\n",
    "        return None  # Or an empty array of the same shape, depending on your preference\n",
    "\n",
    "\n",
    "# Iterate over each file to plot the results\n",
    "for i, f in enumerate(files):\n",
    "    original_image = imgs[i]\n",
    "    blue_channel_image = original_image[:,:,2]  # Extracting the blue channel for visualization\n",
    "    predicted_mask = np.load(f'{os.path.splitext(f)[0]}_masks.npy')\n",
    "    \n",
    "    fig, axs = plt.subplots(1, 3, figsize=(15, 5))\n",
    "    \n",
    "    # Plot original image in the blue channel\n",
    "    axs[0].imshow(blue_channel_image, cmap='gray')\n",
    "    axs[0].set_title('Original Image (Blue Channel)')\n",
    "    axs[0].axis('off')\n",
    "    \n",
    "    # Plot predicted mask\n",
    "    axs[1].imshow(predicted_mask, cmap='jet')\n",
    "    axs[1].set_title('Predicted Mask')\n",
    "    axs[1].axis('off')\n",
    "    \n",
    "    # Plot prediction overlay on the blue channel image\n",
    "    axs[2].imshow(blue_channel_image, cmap='gray')  # Show the original image in grayscale\n",
    "    axs[2].imshow(predicted_mask, cmap='jet', alpha=0.5)  # Overlay the predicted mask with some transparency\n",
    "    axs[2].set_title('Prediction on Original')\n",
    "    axs[2].axis('off')\n",
    "    \n",
    "    plt.show()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "362aec3f-ecca-4f22-97f9-abe54a459c6f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "# Assuming 'predicted_mask' is loaded as shown in previous examples\n",
    "# Loop through all predicted masks\n",
    "for i, f in enumerate(files):\n",
    "    predicted_mask = np.load(f'{os.path.splitext(f)[0]}_masks.npy')\n",
    "    \n",
    "    # Find unique values in the mask, excluding 0 (background)\n",
    "    unique_objects = np.unique(predicted_mask)\n",
    "    num_predictions = len(unique_objects) - 1 if 0 in unique_objects else len(unique_objects)\n",
    "    \n",
    "    print(f'Image {i+1} ({os.path.basename(f)}): {num_predictions} predictions')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bf040de6-bf35-4705-b379-dc230687f216",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "from scipy import ndimage\n",
    "\n",
    "def read_ground_truth_boxes(label_path, image_width=640):\n",
    "    boxes = []\n",
    "    with open(label_path, 'r', encoding='utf-8', errors='replace') as f:\n",
    "        for line in f:\n",
    "            try:\n",
    "                _, x_center_norm, y_center_norm, width_norm, height_norm = map(float, line.split())\n",
    "                x_tl = (x_center_norm - width_norm / 2) * image_width\n",
    "                y_tl = (y_center_norm - height_norm / 2) * image_width\n",
    "                width = width_norm * image_width\n",
    "                height = height_norm * image_width\n",
    "                boxes.append((x_tl, y_tl, width, height))\n",
    "            except ValueError:\n",
    "                continue\n",
    "    return boxes\n",
    "\n",
    "label_folder = '/rsrch5/home/plm/yshokrollahi/project4/val_pack/labels'\n",
    "label_files = [os.path.join(label_folder, f) for f in os.listdir(label_folder) if f.endswith('.txt')]\n",
    "ground_truth_boxes_list = [read_ground_truth_boxes(f) for f in label_files]\n",
    "\n",
    "def calculate_metrics(predicted_centers, ground_truth_boxes):\n",
    "    TP = 0\n",
    "    for pc in predicted_centers:\n",
    "        for (x_tl, y_tl, width, height) in ground_truth_boxes:\n",
    "            x_br = x_tl + width\n",
    "            y_br = y_tl + height\n",
    "            if x_tl <= pc[1] <= x_br and y_tl <= pc[0] <= y_br:  # pc is (y,x) because of ndimage.center_of_mass\n",
    "                TP += 1\n",
    "                break\n",
    "\n",
    "    FP = len(predicted_centers) - TP\n",
    "    FN = len(ground_truth_boxes) - TP\n",
    "    return TP, FP, FN\n",
    "\n",
    "def calculate_precision_recall_f1(TP, FP, FN):\n",
    "    precision = TP / (TP + FP) if TP + FP > 0 else 0\n",
    "    recall = TP / (TP + FN) if TP + FN > 0 else 0\n",
    "    f1_score = 2 * (precision * recall) / (precision + recall) if precision + recall > 0 else 0\n",
    "    return precision, recall, f1_score\n",
    "\n",
    "overall_TP, overall_FP, overall_FN = 0, 0, 0\n",
    "\n",
    "for i, (gt_boxes, file_path) in enumerate(zip(ground_truth_boxes_list, files)):\n",
    "    predicted_mask = np.load(f'{os.path.splitext(file_path)[0]}_masks.npy')\n",
    "    predicted_centers = get_predicted_centers(predicted_mask)\n",
    "    \n",
    "    TP, FP, FN = calculate_metrics(predicted_centers, gt_boxes)\n",
    "    precision, recall, f1_score = calculate_precision_recall_f1(TP, FP, FN)\n",
    "    \n",
    "    overall_TP += TP\n",
    "    overall_FP += FP\n",
    "    overall_FN += FN\n",
    "    \n",
    "    print(f\"Image {i+1}: Precision: {precision}, Recall: {recall}, F1 Score: {f1_score}\")\n",
    "\n",
    "overall_precision, overall_recall, overall_f1_score = calculate_precision_recall_f1(overall_TP, overall_FP, overall_FN)\n",
    "print(f\"Overall: Precision: {overall_precision}, Recall: {overall_recall}, F1 Score: {overall_f1_score}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8210794f-9bc5-4cd1-962e-b8ef29888fd8",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "from scipy import ndimage\n",
    "\n",
    "def read_ground_truth_boxes(label_path, image_width=640):\n",
    "    boxes = []\n",
    "    with open(label_path, 'r', encoding='utf-8', errors='replace') as f:\n",
    "        for line in f:\n",
    "            try:\n",
    "                _, x_center_norm, y_center_norm, width_norm, height_norm = map(float, line.split())\n",
    "                x_tl = (x_center_norm - width_norm / 2) * image_width\n",
    "                y_tl = (y_center_norm - height_norm / 2) * image_width\n",
    "                width = width_norm * image_width\n",
    "                height = height_norm * image_width\n",
    "                boxes.append((x_tl, y_tl, width, height))\n",
    "            except ValueError:\n",
    "                continue\n",
    "    return boxes\n",
    "\n",
    "label_folder = '/rsrch5/home/plm/yshokrollahi/project4/val_pack/labels'\n",
    "image_folder = '/rsrch5/home/plm/yshokrollahi/project4/val_pack/images'  # Adjusted to point to the correct masks directory\n",
    "\n",
    "label_files = [\n",
    "    os.path.join(label_folder, f) for f in os.listdir(label_folder) \n",
    "    if f.endswith('.txt') and not f.startswith('.')\n",
    "]\n",
    "ground_truth_boxes_list = [read_ground_truth_boxes(f) for f in label_files]\n",
    "\n",
    "def calculate_metrics(predicted_centers, ground_truth_boxes):\n",
    "    TP = 0\n",
    "    for pc in predicted_centers:\n",
    "        for (x_tl, y_tl, width, height) in ground_truth_boxes:\n",
    "            x_br = x_tl + width\n",
    "            y_br = y_tl + height\n",
    "            if x_tl <= pc[1] <= x_br and y_tl <= pc[0] <= y_br:  # pc is (y,x) because of ndimage.center_of_mass\n",
    "                TP += 1\n",
    "                break\n",
    "\n",
    "    FP = len(predicted_centers) - TP\n",
    "    FN = len(ground_truth_boxes) - TP\n",
    "    return TP, FP, FN\n",
    "\n",
    "def calculate_precision_recall_f1(TP, FP, FN):\n",
    "    precision = min(TP / (TP + FP), 1) if TP + FP > 0 else 0\n",
    "    recall = min(TP / (TP + FN), 1) if TP + FN > 0 else 0\n",
    "    f1_score = 2 * (precision * recall) / (precision + recall) if precision + recall > 0 else 0\n",
    "    return precision, recall, f1_score\n",
    "\n",
    "overall_TP, overall_FP, overall_FN = 0, 0, 0\n",
    "\n",
    "# Assuming `get_predicted_centers` is defined elsewhere\n",
    "for i, label_file_path in enumerate(label_files):\n",
    "    base_filename = os.path.basename(os.path.splitext(label_file_path)[0])\n",
    "    mask_file_path = os.path.join(image_folder, f'{base_filename}_masks.npy')\n",
    "\n",
    "    try:\n",
    "        predicted_mask = np.load(mask_file_path)\n",
    "        predicted_centers = get_predicted_centers(predicted_mask)  # Assuming this function is defined elsewhere\n",
    "\n",
    "        TP, FP, FN = calculate_metrics(predicted_centers, ground_truth_boxes_list[i])\n",
    "        precision, recall, f1_score = calculate_precision_recall_f1(TP, FP, FN)\n",
    "        \n",
    "        overall_TP += TP\n",
    "        overall_FP += FP\n",
    "        overall_FN += FN\n",
    "        \n",
    "        print(f\"Image {i+1}: Precision: {precision}, Recall: {recall}, F1 Score: {f1_score}\")\n",
    "    except FileNotFoundError as e:\n",
    "        print(f\"Error loading mask for image {i+1}: {e}\")\n",
    "\n",
    "overall_precision, overall_recall, overall_f1_score = calculate_precision_recall_f1(overall_TP, overall_FP, overall_FN)\n",
    "print(f\"Overall: Precision: {overall_precision}, Recall: {overall_recall}, F1 Score: {overall_f1_score}\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0rc1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
